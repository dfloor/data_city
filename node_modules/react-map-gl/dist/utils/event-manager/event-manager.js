'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _wheelInput = require('./wheel-input');

var _wheelInput2 = _interopRequireDefault(_wheelInput);

var _moveInput = require('./move-input');

var _moveInput2 = _interopRequireDefault(_moveInput);

var _isBrowser = require('../is-browser');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Hammer.js directly references `document` and `window`,
// which means that importing it in environments without
// those objects throws errors. Therefore, instead of
// directly `import`ing 'hammerjs' and './constants'
// (which imports Hammer.js) we conditionally require it
// depending on support for those globals, and provide mocks
// for environments without `document`/`window`.
function ManagerMock(m) {
  var instance = {};
  var chainedNoop = function chainedNoop() {
    return instance;
  };
  instance.on = chainedNoop;
  instance.off = chainedNoop;
  instance.destroy = chainedNoop;
  instance.emit = chainedNoop;
  return instance;
}

var Manager = _isBrowser.isBrowser ? require('hammerjs').Manager : ManagerMock;

var _ref = _isBrowser.isBrowser ? require('./constants') : {
  BASIC_EVENT_ALIASES: {},
  EVENT_RECOGNIZER_MAP: {},
  GESTURE_EVENT_ALIASES: {}
},
    BASIC_EVENT_ALIASES = _ref.BASIC_EVENT_ALIASES,
    EVENT_RECOGNIZER_MAP = _ref.EVENT_RECOGNIZER_MAP,
    RECOGNIZERS = _ref.RECOGNIZERS,
    GESTURE_EVENT_ALIASES = _ref.GESTURE_EVENT_ALIASES;

/**
 * Single API for subscribing to events about both
 * basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
 * and gestural input (e.g. 'click', 'tap', 'panstart').
 * Delegates event registration and handling to Hammer.js.
 * @param {DOM Element} element         DOM element on which event handlers will be registered.
 * @param {Object} options              Options for instantiation
 * @param {Object} options.events       Map of {event name: handler} to register on init.
 * @param {Object} options.recognizers  Gesture recognizers from Hammer.js to register,
 *                                      as an Array in Hammer.Recognizer format.
 *                                      (http://hammerjs.github.io/api/#hammermanager)
 */


var EventManager = function () {
  function EventManager(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, EventManager);

    this.element = element;
    this._onBasicInput = this._onBasicInput.bind(this);
    this.manager = new Manager(element, { recognizers: options.recognizers || RECOGNIZERS }).on('hammer.input', this._onBasicInput);

    this.eventHandlers = [];

    // Handle events not handled by Hammer.js:
    // - mouse wheel
    // - pointer/touch/mouse move
    this._onOtherEvent = this._onOtherEvent.bind(this);
    this.wheelInput = new _wheelInput2.default(element, this._onOtherEvent, { enable: false });
    this.moveInput = new _moveInput2.default(element, this._onOtherEvent, { enable: false });

    // Register all passed events.
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  /**
   * Tear down internal event management implementations.
   */


  (0, _createClass3.default)(EventManager, [{
    key: 'destroy',
    value: function destroy() {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.manager.destroy();
    }

    /**
     * Register an event handler function to be called on `event`.
     * @param {string|Object} event   An event name (String) or map of event names to handlers.
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'on',
    value: function on(event, handler) {
      if (typeof event === 'string') {
        this._addEventHandler(event, handler);
      } else {
        // If `event` is a map, call `on()` for each entry.
        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName]);
        }
      }
    }

    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof event === 'string') {
        this._removeEventHandler(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
      }
    }

    /*
     * Enable/disable recognizer for the given event
     */

  }, {
    key: '_toggleRecognizer',
    value: function _toggleRecognizer(name, enabled) {
      var recognizer = this.manager.get(name);
      if (recognizer) {
        recognizer.set({ enable: enabled });
      }
      this.wheelInput.toggleIfEventSupported(name, enabled);
      this.moveInput.toggleIfEventSupported(name, enabled);
    }

    /**
     * Process the event registration for a single event + handler.
     */

  }, {
    key: '_addEventHandler',
    value: function _addEventHandler(event, handler) {
      var wrappedHandler = this._wrapEventHandler(event, handler);
      // Alias to a recognized gesture as necessary.
      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      // Get recognizer for this event
      var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      // Enable recognizer for this event.
      this._toggleRecognizer(recognizerName, true);

      // Save wrapped handler
      this.eventHandlers.push({ event: event, eventAlias: eventAlias, recognizerName: recognizerName, handler: handler, wrappedHandler: wrappedHandler });

      this.manager.on(eventAlias, wrappedHandler);
    }

    /**
     * Process the event deregistration for a single event + handler.
     */

  }, {
    key: '_removeEventHandler',
    value: function _removeEventHandler(event, handler) {
      var _this = this;

      var success = false;

      // Find saved handler if any.
      for (var i = this.eventHandlers.length; i--;) {
        var entry = this.eventHandlers[i];
        if (entry.event === event && entry.handler === handler) {
          // Deregister event handler.
          this.manager.off(entry.eventAlias, entry.wrappedHandler);
          // Delete saved handler
          this.eventHandlers.splice(i, 1);
          success = true;
        }
      }

      if (success) {
        (function () {
          // Alias to a recognized gesture as necessary.
          var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
          // Get recognizer for this event
          var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
          // Disable recognizer if no more handlers are attached to its events
          var isRecognizerUsed = _this.eventHandlers.find(function (entry) {
            return entry.recognizerName === recognizerName;
          });
          if (!isRecognizerUsed) {
            _this._toggleRecognizer(recognizerName, false);
          }
        })();
      }
    }

    /**
     * Returns an event handler that aliases events and add props before passing
     * to the real handler.
     */

  }, {
    key: '_wrapEventHandler',
    value: function _wrapEventHandler(type, handler) {
      var _this2 = this;

      return function (event) {
        var element = _this2.element;
        var srcEvent = event.srcEvent;


        var center = event.center || {
          x: srcEvent.clientX,
          y: srcEvent.clientY
        };

        // Calculate center relative to the root element
        var rect = element.getBoundingClientRect();
        var offsetCenter = {
          x: center.x - rect.left - element.clientLeft,
          y: center.y - rect.top - element.clientTop
        };

        handler((0, _assign2.default)({}, event, {
          type: type,
          center: center,
          offsetCenter: offsetCenter,
          rootElement: element
        }));
      };
    }

    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: '_onBasicInput',
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;

      var alias = BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        var emitEvent = (0, _assign2.default)({}, event, { type: alias });
        this.manager.emit(alias, emitEvent);
      }
    }

    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: '_onOtherEvent',
    value: function _onOtherEvent(event) {
      this.manager.emit(event.type, event);
    }
  }]);
  return EventManager;
}();

exports.default = EventManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudC1tYW5hZ2VyL2V2ZW50LW1hbmFnZXIuanMiXSwibmFtZXMiOlsiTWFuYWdlck1vY2siLCJtIiwiaW5zdGFuY2UiLCJjaGFpbmVkTm9vcCIsIm9uIiwib2ZmIiwiZGVzdHJveSIsImVtaXQiLCJNYW5hZ2VyIiwicmVxdWlyZSIsIkJBU0lDX0VWRU5UX0FMSUFTRVMiLCJFVkVOVF9SRUNPR05JWkVSX01BUCIsIkdFU1RVUkVfRVZFTlRfQUxJQVNFUyIsIlJFQ09HTklaRVJTIiwiRXZlbnRNYW5hZ2VyIiwiZWxlbWVudCIsIm9wdGlvbnMiLCJfb25CYXNpY0lucHV0IiwiYmluZCIsIm1hbmFnZXIiLCJyZWNvZ25pemVycyIsImV2ZW50SGFuZGxlcnMiLCJfb25PdGhlckV2ZW50Iiwid2hlZWxJbnB1dCIsImVuYWJsZSIsIm1vdmVJbnB1dCIsImV2ZW50cyIsImV2ZW50IiwiaGFuZGxlciIsIl9hZGRFdmVudEhhbmRsZXIiLCJldmVudE5hbWUiLCJfcmVtb3ZlRXZlbnRIYW5kbGVyIiwibmFtZSIsImVuYWJsZWQiLCJyZWNvZ25pemVyIiwiZ2V0Iiwic2V0IiwidG9nZ2xlSWZFdmVudFN1cHBvcnRlZCIsIndyYXBwZWRIYW5kbGVyIiwiX3dyYXBFdmVudEhhbmRsZXIiLCJldmVudEFsaWFzIiwicmVjb2duaXplck5hbWUiLCJfdG9nZ2xlUmVjb2duaXplciIsInB1c2giLCJzdWNjZXNzIiwiaSIsImxlbmd0aCIsImVudHJ5Iiwic3BsaWNlIiwiaXNSZWNvZ25pemVyVXNlZCIsImZpbmQiLCJ0eXBlIiwic3JjRXZlbnQiLCJjZW50ZXIiLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm9mZnNldENlbnRlciIsImxlZnQiLCJjbGllbnRMZWZ0IiwidG9wIiwiY2xpZW50VG9wIiwicm9vdEVsZW1lbnQiLCJhbGlhcyIsImVtaXRFdmVudCJdLCJtYXBwaW5ncyI6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QWU7QUFDbkJOLGFBQUdELE9BQU9DLENBQVAsR0FBV0ksS0FBS0csSUFBaEIsR0FBdUI5QyxRQUFRK0MsVUFEZjtBQUVuQk4sYUFBR0gsT0FBT0csQ0FBUCxHQUFXRSxLQUFLSyxHQUFoQixHQUFzQmhELFFBQVFpRDtBQUZkLFNBQXJCOztBQUtBcEMsZ0JBQVEsc0JBQWMsRUFBZCxFQUFrQkQsS0FBbEIsRUFBeUI7QUFDL0J3QixvQkFEK0I7QUFFL0JFLHdCQUYrQjtBQUcvQk8sb0NBSCtCO0FBSS9CSyx1QkFBYWxEO0FBSmtCLFNBQXpCLENBQVI7QUFNRCxPQXRCRDtBQXVCRDs7QUFFRDs7Ozs7Ozs7OztrQ0FPY1ksSyxFQUFPO0FBQUEsVUFDWnlCLFFBRFksR0FDQXpCLEtBREEsQ0FDWnlCLFFBRFk7O0FBRW5CLFVBQU1jLFFBQVF4RCxvQkFBb0IwQyxTQUFTRCxJQUE3QixDQUFkO0FBQ0EsVUFBSWUsS0FBSixFQUFXO0FBQ1Q7QUFDQSxZQUFNQyxZQUFZLHNCQUFjLEVBQWQsRUFBa0J4QyxLQUFsQixFQUF5QixFQUFDd0IsTUFBTWUsS0FBUCxFQUF6QixDQUFsQjtBQUNBLGFBQUsvQyxPQUFMLENBQWFaLElBQWIsQ0FBa0IyRCxLQUFsQixFQUF5QkMsU0FBekI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O2tDQUljeEMsSyxFQUFPO0FBQ25CLFdBQUtSLE9BQUwsQ0FBYVosSUFBYixDQUFrQm9CLE1BQU13QixJQUF4QixFQUE4QnhCLEtBQTlCO0FBQ0Q7Ozs7O2tCQXBMa0JiLFkiLCJmaWxlIjoiZXZlbnQtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXaGVlbElucHV0IGZyb20gJy4vd2hlZWwtaW5wdXQnO1xuaW1wb3J0IE1vdmVJbnB1dCBmcm9tICcuL21vdmUtaW5wdXQnO1xuaW1wb3J0IHtpc0Jyb3dzZXJ9IGZyb20gJy4uL2lzLWJyb3dzZXInO1xuXG4vLyBIYW1tZXIuanMgZGlyZWN0bHkgcmVmZXJlbmNlcyBgZG9jdW1lbnRgIGFuZCBgd2luZG93YCxcbi8vIHdoaWNoIG1lYW5zIHRoYXQgaW1wb3J0aW5nIGl0IGluIGVudmlyb25tZW50cyB3aXRob3V0XG4vLyB0aG9zZSBvYmplY3RzIHRocm93cyBlcnJvcnMuIFRoZXJlZm9yZSwgaW5zdGVhZCBvZlxuLy8gZGlyZWN0bHkgYGltcG9ydGBpbmcgJ2hhbW1lcmpzJyBhbmQgJy4vY29uc3RhbnRzJ1xuLy8gKHdoaWNoIGltcG9ydHMgSGFtbWVyLmpzKSB3ZSBjb25kaXRpb25hbGx5IHJlcXVpcmUgaXRcbi8vIGRlcGVuZGluZyBvbiBzdXBwb3J0IGZvciB0aG9zZSBnbG9iYWxzLCBhbmQgcHJvdmlkZSBtb2Nrc1xuLy8gZm9yIGVudmlyb25tZW50cyB3aXRob3V0IGBkb2N1bWVudGAvYHdpbmRvd2AuXG5mdW5jdGlvbiBNYW5hZ2VyTW9jayhtKSB7XG4gIGNvbnN0IGluc3RhbmNlID0ge307XG4gIGNvbnN0IGNoYWluZWROb29wID0gKCkgPT4gaW5zdGFuY2U7XG4gIGluc3RhbmNlLm9uID0gY2hhaW5lZE5vb3A7XG4gIGluc3RhbmNlLm9mZiA9IGNoYWluZWROb29wO1xuICBpbnN0YW5jZS5kZXN0cm95ID0gY2hhaW5lZE5vb3A7XG4gIGluc3RhbmNlLmVtaXQgPSBjaGFpbmVkTm9vcDtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5jb25zdCBNYW5hZ2VyID0gaXNCcm93c2VyID8gcmVxdWlyZSgnaGFtbWVyanMnKS5NYW5hZ2VyIDogTWFuYWdlck1vY2s7XG5jb25zdCB7XG4gIEJBU0lDX0VWRU5UX0FMSUFTRVMsXG4gIEVWRU5UX1JFQ09HTklaRVJfTUFQLFxuICBSRUNPR05JWkVSUyxcbiAgR0VTVFVSRV9FVkVOVF9BTElBU0VTXG59ID0gaXNCcm93c2VyID8gcmVxdWlyZSgnLi9jb25zdGFudHMnKSA6IHtcbiAgQkFTSUNfRVZFTlRfQUxJQVNFUzoge30sXG4gIEVWRU5UX1JFQ09HTklaRVJfTUFQOiB7fSxcbiAgR0VTVFVSRV9FVkVOVF9BTElBU0VTOiB7fVxufTtcblxuLyoqXG4gKiBTaW5nbGUgQVBJIGZvciBzdWJzY3JpYmluZyB0byBldmVudHMgYWJvdXQgYm90aFxuICogYmFzaWMgaW5wdXQgZXZlbnRzIChlLmcuICdtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd3aGVlbCcpXG4gKiBhbmQgZ2VzdHVyYWwgaW5wdXQgKGUuZy4gJ2NsaWNrJywgJ3RhcCcsICdwYW5zdGFydCcpLlxuICogRGVsZWdhdGVzIGV2ZW50IHJlZ2lzdHJhdGlvbiBhbmQgaGFuZGxpbmcgdG8gSGFtbWVyLmpzLlxuICogQHBhcmFtIHtET00gRWxlbWVudH0gZWxlbWVudCAgICAgICAgIERPTSBlbGVtZW50IG9uIHdoaWNoIGV2ZW50IGhhbmRsZXJzIHdpbGwgYmUgcmVnaXN0ZXJlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICBPcHRpb25zIGZvciBpbnN0YW50aWF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5ldmVudHMgICAgICAgTWFwIG9mIHtldmVudCBuYW1lOiBoYW5kbGVyfSB0byByZWdpc3RlciBvbiBpbml0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucmVjb2duaXplcnMgIEdlc3R1cmUgcmVjb2duaXplcnMgZnJvbSBIYW1tZXIuanMgdG8gcmVnaXN0ZXIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgYW4gQXJyYXkgaW4gSGFtbWVyLlJlY29nbml6ZXIgZm9ybWF0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2FwaS8jaGFtbWVybWFuYWdlcilcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9vbkJhc2ljSW5wdXQgPSB0aGlzLl9vbkJhc2ljSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hbmFnZXIgPSBuZXcgTWFuYWdlcihlbGVtZW50LCB7cmVjb2duaXplcnM6IG9wdGlvbnMucmVjb2duaXplcnMgfHwgUkVDT0dOSVpFUlN9KVxuICAgICAgLm9uKCdoYW1tZXIuaW5wdXQnLCB0aGlzLl9vbkJhc2ljSW5wdXQpO1xuXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICAvLyBIYW5kbGUgZXZlbnRzIG5vdCBoYW5kbGVkIGJ5IEhhbW1lci5qczpcbiAgICAvLyAtIG1vdXNlIHdoZWVsXG4gICAgLy8gLSBwb2ludGVyL3RvdWNoL21vdXNlIG1vdmVcbiAgICB0aGlzLl9vbk90aGVyRXZlbnQgPSB0aGlzLl9vbk90aGVyRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLndoZWVsSW5wdXQgPSBuZXcgV2hlZWxJbnB1dChlbGVtZW50LCB0aGlzLl9vbk90aGVyRXZlbnQsIHtlbmFibGU6IGZhbHNlfSk7XG4gICAgdGhpcy5tb3ZlSW5wdXQgPSBuZXcgTW92ZUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcblxuICAgIC8vIFJlZ2lzdGVyIGFsbCBwYXNzZWQgZXZlbnRzLlxuICAgIGNvbnN0IHtldmVudHN9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICB0aGlzLm9uKGV2ZW50cyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRlYXIgZG93biBpbnRlcm5hbCBldmVudCBtYW5hZ2VtZW50IGltcGxlbWVudGF0aW9ucy5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy53aGVlbElucHV0LmRlc3Ryb3koKTtcbiAgICB0aGlzLm1vdmVJbnB1dC5kZXN0cm95KCk7XG4gICAgdGhpcy5tYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgZXZlbnRgLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV2ZW50ICAgQW4gZXZlbnQgbmFtZSAoU3RyaW5nKSBvciBtYXAgb2YgZXZlbnQgbmFtZXMgdG8gaGFuZGxlcnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSAgICBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGBldmVudGAuXG4gICAqL1xuICBvbihldmVudCwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvbigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgcHJldmlvdXNseS1yZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXZlbnQgICBBbiBldmVudCBuYW1lIChTdHJpbmcpIG9yIG1hcCBvZiBldmVudCBuYW1lcyB0byBoYW5kbGVyc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgZXZlbnRgLlxuICAgKi9cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGBldmVudGAgaXMgYSBtYXAsIGNhbGwgYG9mZigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIEVuYWJsZS9kaXNhYmxlIHJlY29nbml6ZXIgZm9yIHRoZSBnaXZlbiBldmVudFxuICAgKi9cbiAgX3RvZ2dsZVJlY29nbml6ZXIobmFtZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHJlY29nbml6ZXIgPSB0aGlzLm1hbmFnZXIuZ2V0KG5hbWUpO1xuICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICByZWNvZ25pemVyLnNldCh7ZW5hYmxlOiBlbmFibGVkfSk7XG4gICAgfVxuICAgIHRoaXMud2hlZWxJbnB1dC50b2dnbGVJZkV2ZW50U3VwcG9ydGVkKG5hbWUsIGVuYWJsZWQpO1xuICAgIHRoaXMubW92ZUlucHV0LnRvZ2dsZUlmRXZlbnRTdXBwb3J0ZWQobmFtZSwgZW5hYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgZXZlbnQgcmVnaXN0cmF0aW9uIGZvciBhIHNpbmdsZSBldmVudCArIGhhbmRsZXIuXG4gICAqL1xuICBfYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgY29uc3Qgd3JhcHBlZEhhbmRsZXIgPSB0aGlzLl93cmFwRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAvLyBBbGlhcyB0byBhIHJlY29nbml6ZWQgZ2VzdHVyZSBhcyBuZWNlc3NhcnkuXG4gICAgY29uc3QgZXZlbnRBbGlhcyA9IEdFU1RVUkVfRVZFTlRfQUxJQVNFU1tldmVudF0gfHwgZXZlbnQ7XG4gICAgLy8gR2V0IHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnRcbiAgICBjb25zdCByZWNvZ25pemVyTmFtZSA9IEVWRU5UX1JFQ09HTklaRVJfTUFQW2V2ZW50QWxpYXNdIHx8IGV2ZW50QWxpYXM7XG4gICAgLy8gRW5hYmxlIHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihyZWNvZ25pemVyTmFtZSwgdHJ1ZSk7XG5cbiAgICAvLyBTYXZlIHdyYXBwZWQgaGFuZGxlclxuICAgIHRoaXMuZXZlbnRIYW5kbGVycy5wdXNoKHtldmVudCwgZXZlbnRBbGlhcywgcmVjb2duaXplck5hbWUsIGhhbmRsZXIsIHdyYXBwZWRIYW5kbGVyfSk7XG5cbiAgICB0aGlzLm1hbmFnZXIub24oZXZlbnRBbGlhcywgd3JhcHBlZEhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIGV2ZW50IGRlcmVnaXN0cmF0aW9uIGZvciBhIHNpbmdsZSBldmVudCArIGhhbmRsZXIuXG4gICAqL1xuICBfcmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgIC8vIEZpbmQgc2F2ZWQgaGFuZGxlciBpZiBhbnkuXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuZXZlbnRIYW5kbGVycy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5ldmVudEhhbmRsZXJzW2ldO1xuICAgICAgaWYgKGVudHJ5LmV2ZW50ID09PSBldmVudCAmJiBlbnRyeS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgIC8vIERlcmVnaXN0ZXIgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLm9mZihlbnRyeS5ldmVudEFsaWFzLCBlbnRyeS53cmFwcGVkSGFuZGxlcik7XG4gICAgICAgIC8vIERlbGV0ZSBzYXZlZCBoYW5kbGVyXG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAvLyBBbGlhcyB0byBhIHJlY29nbml6ZWQgZ2VzdHVyZSBhcyBuZWNlc3NhcnkuXG4gICAgICBjb25zdCBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcbiAgICAgIC8vIEdldCByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50XG4gICAgICBjb25zdCByZWNvZ25pemVyTmFtZSA9IEVWRU5UX1JFQ09HTklaRVJfTUFQW2V2ZW50QWxpYXNdIHx8IGV2ZW50QWxpYXM7XG4gICAgICAvLyBEaXNhYmxlIHJlY29nbml6ZXIgaWYgbm8gbW9yZSBoYW5kbGVycyBhcmUgYXR0YWNoZWQgdG8gaXRzIGV2ZW50c1xuICAgICAgY29uc3QgaXNSZWNvZ25pemVyVXNlZCA9IHRoaXMuZXZlbnRIYW5kbGVycy5maW5kKFxuICAgICAgICBlbnRyeSA9PiBlbnRyeS5yZWNvZ25pemVyTmFtZSA9PT0gcmVjb2duaXplck5hbWVcbiAgICAgICk7XG4gICAgICBpZiAoIWlzUmVjb2duaXplclVzZWQpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihyZWNvZ25pemVyTmFtZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV2ZW50IGhhbmRsZXIgdGhhdCBhbGlhc2VzIGV2ZW50cyBhbmQgYWRkIHByb3BzIGJlZm9yZSBwYXNzaW5nXG4gICAqIHRvIHRoZSByZWFsIGhhbmRsZXIuXG4gICAqL1xuICBfd3JhcEV2ZW50SGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtlbGVtZW50fSA9IHRoaXM7XG4gICAgICBjb25zdCB7c3JjRXZlbnR9ID0gZXZlbnQ7XG5cbiAgICAgIGNvbnN0IGNlbnRlciA9IGV2ZW50LmNlbnRlciB8fCB7XG4gICAgICAgIHg6IHNyY0V2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IHNyY0V2ZW50LmNsaWVudFlcbiAgICAgIH07XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBjZW50ZXIgcmVsYXRpdmUgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBvZmZzZXRDZW50ZXIgPSB7XG4gICAgICAgIHg6IGNlbnRlci54IC0gcmVjdC5sZWZ0IC0gZWxlbWVudC5jbGllbnRMZWZ0LFxuICAgICAgICB5OiBjZW50ZXIueSAtIHJlY3QudG9wIC0gZWxlbWVudC5jbGllbnRUb3BcbiAgICAgIH07XG5cbiAgICAgIGhhbmRsZXIoT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2VudGVyLFxuICAgICAgICBvZmZzZXRDZW50ZXIsXG4gICAgICAgIHJvb3RFbGVtZW50OiBlbGVtZW50XG4gICAgICB9KSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYmFzaWMgZXZlbnRzIHVzaW5nIHRoZSAnaGFtbWVyLmlucHV0JyBIYW1tZXIuanMgQVBJOlxuICAgKiBCZWZvcmUgcnVubmluZyBSZWNvZ25pemVycywgSGFtbWVyIGVtaXRzIGEgJ2hhbW1lci5pbnB1dCcgZXZlbnRcbiAgICogd2l0aCB0aGUgYmFzaWMgZXZlbnQgaW5mby4gVGhpcyBmdW5jdGlvbiBlbWl0cyBhbGwgYmFzaWMgZXZlbnRzXG4gICAqIGFsaWFzZWQgdG8gdGhlIFwiY2xhc3NcIiBvZiBldmVudCByZWNlaXZlZC5cbiAgICogU2VlIGNvbnN0YW50cy5CQVNJQ19FVkVOVF9DTEFTU0VTIGJhc2ljIGV2ZW50IGNsYXNzIGRlZmluaXRpb25zLlxuICAgKi9cbiAgX29uQmFzaWNJbnB1dChldmVudCkge1xuICAgIGNvbnN0IHtzcmNFdmVudH0gPSBldmVudDtcbiAgICBjb25zdCBhbGlhcyA9IEJBU0lDX0VWRU5UX0FMSUFTRVNbc3JjRXZlbnQudHlwZV07XG4gICAgaWYgKGFsaWFzKSB7XG4gICAgICAvLyBmaXJlIGFsbCBldmVudHMgYWxpYXNlZCB0byBzcmNFdmVudC50eXBlXG4gICAgICBjb25zdCBlbWl0RXZlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCwge3R5cGU6IGFsaWFzfSk7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdChhbGlhcywgZW1pdEV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGV2ZW50cyBub3Qgc3VwcG9ydGVkIGJ5IEhhbW1lci5qcyxcbiAgICogYW5kIHBpcGUgYmFjayBvdXQgdGhyb3VnaCBzYW1lIChIYW1tZXIpIGNoYW5uZWwgdXNlZCBieSBvdGhlciBldmVudHMuXG4gICAqL1xuICBfb25PdGhlckV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYW5hZ2VyLmVtaXQoZXZlbnQudHlwZSwgZXZlbnQpO1xuICB9XG5cbn1cbiJdfQ==