{"version":3,"sources":["../../../src/shadertools/lib/assemble-shaders.js"],"names":["assembleShaders","VERTEX_SHADER","FRAGMENT_SHADER","SHADER_TYPE","MODULE_INJECTORS","FRAGMENT_SHADER_PROLOGUE","getShaderName","id","source","type","injectShaderName","indexOf","getApplicationDefines","defines","count","sourceText","define","toUpperCase","getModuleSource","moduleName","shaderModule","moduleSource","vs","vertexShader","fs","fragmentShader","assembleShader","gl","modules","assembledSource","inject","replace","assembleGetUniforms","getUniforms","opts","uniforms","moduleUniforms","Object","assign","assembleModuleMap","result"],"mappings":"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","file":"assemble-shaders.js","sourcesContent":["import {resolveModules, getShaderModule} from './shader-modules';\nimport {getPlatformShaderDefines, VERSION_DEFINES} from './platform-defines';\nimport {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport assert from 'assert';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n`;\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n` : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n    sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\n// Extracts the source code chunk for the specified shader type from the named shader module\nfunction getModuleSource(moduleName, type) {\n  const shaderModule = getShaderModule(moduleName);\n  let moduleSource;\n  switch (type) {\n  case VERTEX_SHADER:\n    moduleSource = shaderModule.vs || shaderModule.vertexShader;\n    break;\n  case FRAGMENT_SHADER:\n    moduleSource = shaderModule.fs || shaderModule.fragmentShader;\n    break;\n  default:\n    assert(false);\n  }\n\n  if (typeof moduleSource !== 'string') {\n    return '';\n  }\n\n  return `\\\n#define MODULE_${moduleName.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${moduleName}\n\n`;\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(gl, {\n  id,\n  source,\n  type,\n  modules = [],\n  defines = {}\n}) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = `\\\n${getShaderName({id, source, type})}\n${getPlatformShaderDefines(gl)}\n${VERSION_DEFINES}\n${getApplicationDefines(defines)}\n${type === FRAGMENT_SHADER ? FRAGMENT_SHADER_PROLOGUE : ''}\n`;\n\n  // Add source of dependent modules in resolved order\n  let inject = false;\n  for (const moduleName of modules) {\n    switch (moduleName) {\n    case 'inject':\n      inject = true;\n      break;\n    default:\n      // Add the module source, and a #define that declares it presence\n      assembledSource += getModuleSource(moduleName, type);\n    }\n  }\n\n  // Add the actual source of this shader\n  assembledSource += source;\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (inject) {\n    assembledSource.replace('}\\s*$', MODULE_INJECTORS);\n  }\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const moduleName of modules) {\n      const shaderModule = getShaderModule(moduleName);\n      const moduleUniforms = shaderModule.getUniforms ? shaderModule.getUniforms(opts) : {};\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\n/**\n * Apply set of modules\n */\nexport function assembleShaders(gl, opts = {}) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n"]}